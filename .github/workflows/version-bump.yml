name: Version Bump

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: "Version bump type"
        required: true
        default: "patch"
        type: choice
        options:
          - patch
          - minor
          - major
      custom_version:
        description: "Custom version (optional, overrides version_type)"
        required: false
        type: string

jobs:
  bump-version:
    name: Bump Version and Create Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Deno
        uses: denoland/setup-deno@v1
        with:
          deno-version: 2.x

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get current version
        id: current_version
        run: |
          CURRENT_VERSION=$(jq -r '.version' deno.json)
          echo "current=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Calculate new version
        id: new_version
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.current }}"
          CUSTOM_VERSION="${{ github.event.inputs.custom_version }}"
          VERSION_TYPE="${{ github.event.inputs.version_type }}"

          if [ -n "$CUSTOM_VERSION" ]; then
            NEW_VERSION="$CUSTOM_VERSION"
            echo "Using custom version: $NEW_VERSION"
          else
            # Parse current version
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            MAJOR=${VERSION_PARTS[0]}
            MINOR=${VERSION_PARTS[1]}
            PATCH=${VERSION_PARTS[2]}

            case $VERSION_TYPE in
              "major")
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              "minor")
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              "patch")
                PATCH=$((PATCH + 1))
                ;;
            esac

            NEW_VERSION="$MAJOR.$MINOR.$PATCH"
            echo "Calculated new version: $NEW_VERSION (${VERSION_TYPE} bump)"
          fi

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Update deno.json version
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.version }}"
          jq --arg version "$NEW_VERSION" '.version = $version' deno.json > deno.json.tmp
          mv deno.json.tmp deno.json
          echo "Updated deno.json to version $NEW_VERSION"

      - name: Run tests to ensure everything works
        env:
          LINGO_API_KEY: ${{ secrets.LINGO_API_KEY }}
        run: |
          deno fmt --check
          deno lint
          deno check src/mod.ts
          deno test --allow-net tests/
          deno publish --dry-run --allow-dirty

      - name: Commit version bump
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.version }}"
          git add deno.json
          git commit -m "chore: bump version to v$NEW_VERSION"
          git push origin main

      - name: Create and push tag
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.version }}"
          git tag "v$NEW_VERSION"
          git push origin "v$NEW_VERSION"
          echo "Created and pushed tag v$NEW_VERSION"

      - name: Create Release Notes
        id: release_notes
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.version }}"

          # Generate changelog since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -n "$LAST_TAG" ]; then
            echo "## What's Changed" > release_notes.md
            echo "" >> release_notes.md
            git log ${LAST_TAG}..HEAD --pretty=format:"* %s (%h)" >> release_notes.md
            echo "" >> release_notes.md
          else
            echo "## What's Changed" > release_notes.md
            echo "" >> release_notes.md
            echo "* Initial release of Lingo.dev Deno SDK" >> release_notes.md
            echo "" >> release_notes.md
          fi

          cat >> release_notes.md << 'EOF'

          ### Installation

          **JSR (Recommended):**
          ```bash
          deno add @lingodotdev/deno-sdk
          ```

          **Deno Land:**
          ```typescript
          import { LingoDotDevEngine } from "https://deno.land/x/lingodotdev@vNEW_VERSION/mod.ts";
          ```

          ### Usage

          ```typescript
          import { LingoDotDevEngine } from "@lingodotdev/deno-sdk";

          const engine = new LingoDotDevEngine({
            apiKey: "your-api-key"
          });

          const result = await engine.localizeText("Hello world", {
            sourceLocale: "en",
            targetLocale: "es"
          });
          ```

          See the [README](https://github.com/lingodotdev/sdk-deno#readme) for full documentation.
          EOF

          # Replace NEW_VERSION placeholder
          sed -i "s/NEW_VERSION/$NEW_VERSION/g" release_notes.md

          echo "Generated release notes:"
          cat release_notes.md

      - name: Summary
        run: |
          NEW_VERSION="${{ steps.new_version.outputs.version }}"
          echo "ðŸŽ‰ Successfully bumped version to v$NEW_VERSION"
          echo "ðŸ“¦ Tag v$NEW_VERSION has been created and pushed"
          echo "ðŸš€ Release workflow will be triggered automatically"
          echo ""
          echo "The release will be published to:"
          echo "- JSR Registry: @lingodotdev/deno-sdk"
          echo "- Deno Land: https://deno.land/x/lingodotdev@v$NEW_VERSION"
